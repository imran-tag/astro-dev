<!-- portal/templates/portal/base_offline.html -->
{% load static %}
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>{% block title %}Astro Tech Technician{% endblock %}</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- PWA Meta tags -->
    <meta name="theme-color" content="#14224A">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Astro Tech">

    {% block extra_head %}{% endblock %}

    <style>
        /* Basic styles */
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        input, textarea {
            -webkit-user-select: text;
            user-select: text;
        }

        /* Offline indicator */
        .offline-status {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #fbbf24;
            color: white;
            text-align: center;
            padding: 8px;
            font-size: 14px;
            z-index: 50;
            display: none;
        }

        .offline-mode {
            filter: grayscale(10%);
        }
    </style>
</head>
<body class="bg-white min-h-screen">
    <!-- Offline Status Bar -->
    <div id="offline-status" class="offline-status">
        ðŸ”„ Travail hors ligne â€“ Votre travail est enregistrÃ© localement.
    </div>

    <!-- Main Content -->
    <main id="main-content">
        {% block content %}{% endblock %}
    </main>

    <!-- Simple offline detection -->
    <script>
        // Simple connection monitoring
        function updateOfflineStatus() {
            const offlineStatus = document.getElementById('offline-status');
            const body = document.body;

            if (!navigator.onLine) {
                offlineStatus.style.display = 'block';
                body.classList.add('offline-mode');
                // Adjust body padding to account for status bar
                body.style.paddingTop = offlineStatus.offsetHeight + 'px';
            } else {
                offlineStatus.style.display = 'none';
                body.classList.remove('offline-mode');
                body.style.paddingTop = '0px';
            }
        }

        // Check on page load
        document.addEventListener('DOMContentLoaded', updateOfflineStatus);

        // Monitor connection changes
        window.addEventListener('online', function() {
            updateOfflineStatus();
            console.log('Back online!');
        });

        window.addEventListener('offline', function() {
            updateOfflineStatus();
            console.log('Gone offline - working in offline mode');
        });

        // Global functions for compatibility
        window.openGallery = function() {
            const input = document.getElementById('imageInput');
            if (input) {
                input.removeAttribute('capture');
                input.click();
            }
        };

        window.openCamera = function() {
            const input = document.getElementById('imageInput');
            if (input) {
                input.setAttribute('capture', 'environment');
                input.click();
            }
        };
        // portal/static/js/offline-storage.js
class OfflineStorageManager {
    constructor() {
        this.dbName = 'AstroTechDB';
        this.dbVersion = 1;
        this.db = null;
        this.init();
    }

    async init() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.dbVersion);

            request.onerror = () => reject(request.error);
            request.onsuccess = () => {
                this.db = request.result;
                resolve(this.db);
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;

                // Store for images
                if (!db.objectStoreNames.contains('images')) {
                    const imageStore = db.createObjectStore('images', { keyPath: 'id', autoIncrement: true });
                    imageStore.createIndex('interventionId', 'interventionId', { unique: false });
                    imageStore.createIndex('type', 'type', { unique: false });
                    imageStore.createIndex('uploaded', 'uploaded', { unique: false });
                }

                // Store for form data
                if (!db.objectStoreNames.contains('formData')) {
                    const formStore = db.createObjectStore('formData', { keyPath: 'id' });
                    formStore.createIndex('interventionId', 'interventionId', { unique: false });
                    formStore.createIndex('synced', 'synced', { unique: false });
                }

                // Store for interventions (for offline viewing)
                if (!db.objectStoreNames.contains('interventions')) {
                    const interventionStore = db.createObjectStore('interventions', { keyPath: 'uid' });
                    interventionStore.createIndex('lastUpdated', 'lastUpdated', { unique: false });
                }
            };
        });
    }

    // Store image locally
    async storeImage(interventionId, file, type = 'before') {
        const imageData = {
            interventionId: interventionId,
            type: type, // 'before' or 'after'
            file: file,
            filename: file.name,
            size: file.size,
            mimeType: file.type,
            timestamp: new Date().toISOString(),
            uploaded: false
        };

        const transaction = this.db.transaction(['images'], 'readwrite');
        const store = transaction.objectStore('images');
        return store.add(imageData);
    }

    // Get images for an intervention
    async getImages(interventionId, type = null) {
        const transaction = this.db.transaction(['images'], 'readonly');
        const store = transaction.objectStore('images');
        const index = store.index('interventionId');

        return new Promise((resolve, reject) => {
            const request = index.getAll(interventionId);
            request.onsuccess = () => {
                let images = request.result;
                if (type) {
                    images = images.filter(img => img.type === type);
                }
                resolve(images);
            };
            request.onerror = () => reject(request.error);
        });
    }

    // Store form data
    async storeFormData(interventionId, stepName, data) {
        const formData = {
            id: `${interventionId}_${stepName}`,
            interventionId: interventionId,
            stepName: stepName,
            data: data,
            timestamp: new Date().toISOString(),
            synced: false
        };

        const transaction = this.db.transaction(['formData'], 'readwrite');
        const store = transaction.objectStore('formData');
        return store.put(formData);
    }

    // Get form data
    async getFormData(interventionId, stepName = null) {
        const transaction = this.db.transaction(['formData'], 'readonly');
        const store = transaction.objectStore('formData');

        if (stepName) {
            return new Promise((resolve, reject) => {
                const request = store.get(`${interventionId}_${stepName}`);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        } else {
            const index = store.index('interventionId');
            return new Promise((resolve, reject) => {
                const request = index.getAll(interventionId);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }
    }

    // Get all unsynced data
    async getUnsyncedData() {
        const transaction = this.db.transaction(['images', 'formData'], 'readonly');

        const unuploadedImages = await new Promise((resolve, reject) => {
            const store = transaction.objectStore('images');
            const index = store.index('uploaded');
            const request = index.getAll(false);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });

        const unsyncedForms = await new Promise((resolve, reject) => {
            const store = transaction.objectStore('formData');
            const index = store.index('synced');
            const request = index.getAll(false);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });

        return { images: unuploadedImages, forms: unsyncedForms };
    }

    // Mark image as uploaded
    async markImageUploaded(imageId, serverPath = null) {
        const transaction = this.db.transaction(['images'], 'readwrite');
        const store = transaction.objectStore('images');

        return new Promise((resolve, reject) => {
            const request = store.get(imageId);
            request.onsuccess = () => {
                const image = request.result;
                if (image) {
                    image.uploaded = true;
                    if (serverPath) image.serverPath = serverPath;
                    image.uploadedAt = new Date().toISOString();

                    const updateRequest = store.put(image);
                    updateRequest.onsuccess = () => resolve(updateRequest.result);
                    updateRequest.onerror = () => reject(updateRequest.error);
                } else {
                    reject(new Error('Image non trouvÃ©e'));
                }
            };
            request.onerror = () => reject(request.error);
        });
    }

    // Mark form data as synced
    async markFormSynced(formId) {
        const transaction = this.db.transaction(['formData'], 'readwrite');
        const store = transaction.objectStore('formData');

        return new Promise((resolve, reject) => {
            const request = store.get(formId);
            request.onsuccess = () => {
                const form = request.result;
                if (form) {
                    form.synced = true;
                    form.syncedAt = new Date().toISOString();

                    const updateRequest = store.put(form);
                    updateRequest.onsuccess = () => resolve(updateRequest.result);
                    updateRequest.onerror = () => reject(updateRequest.error);
                } else {
                    reject(new Error(' DonnÃ©es du formulaire introuvables.'));
                }
            };
            request.onerror = () => reject(request.error);
        });
    }

    // Store intervention data for offline viewing
    async storeIntervention(intervention) {
        intervention.lastUpdated = new Date().toISOString();
        const transaction = this.db.transaction(['interventions'], 'readwrite');
        const store = transaction.objectStore('interventions');
        return store.put(intervention);
    }

    // Get stored interventions
    async getStoredInterventions() {
        const transaction = this.db.transaction(['interventions'], 'readonly');
        const store = transaction.objectStore('interventions');

        return new Promise((resolve, reject) => {
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    // Clear old data (cleanup)
    async clearOldData(daysOld = 7) {
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - daysOld);

        const transaction = this.db.transaction(['images', 'formData'], 'readwrite');

        // Clear old uploaded images
        const imageStore = transaction.objectStore('images');
        const imageRequest = imageStore.getAll();
        imageRequest.onsuccess = () => {
            imageRequest.result.forEach(image => {
                if (image.uploaded && new Date(image.uploadedAt) < cutoffDate) {
                    imageStore.delete(image.id);
                }
            });
        };

        // Clear old synced form data
        const formStore = transaction.objectStore('formData');
        const formRequest = formStore.getAll();
        formRequest.onsuccess = () => {
            formRequest.result.forEach(form => {
                if (form.synced && new Date(form.syncedAt) < cutoffDate) {
                    formStore.delete(form.id);
                }
            });
        };
    }
}

// Initialize global storage manager
window.offlineStorage = new OfflineStorageManager();

// portal/static/js/sync-manager.js
class SyncManager {
    constructor() {
        this.isOnline = navigator.onLine;
        this.syncInProgress = false;
        this.syncQueue = [];
        this.maxRetries = 3;
        this.retryDelay = 5000; // 5 seconds

        this.setupEventListeners();
        this.startPeriodicSync();
    }

    setupEventListeners() {
        // Listen for online/offline events
        window.addEventListener('online', () => {
            this.isOnline = true;
            this.showStatus('Connexion rÃ©tablie â€“ synchronisation des donnÃ©es en cours...', 'success');
            this.syncAll();
        });

        window.addEventListener('offline', () => {
            this.isOnline = false;
            this.showStatus('Travail hors ligne â€“ les donnÃ©es seront synchronisÃ©es lorsque la connexion sera rÃ©tablie.', 'warning');
        });

        // Listen for page visibility changes
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && this.isOnline) {
                this.syncAll();
            }
        });
    }

    startPeriodicSync() {
        // Sync every 30 seconds when online
        setInterval(() => {
            if (this.isOnline && !this.syncInProgress) {
                this.syncAll();
            }
        }, 30000);
    }

    async syncAll() {
        if (this.syncInProgress) return;

        this.syncInProgress = true;

        try {
            const unsyncedData = await window.offlineStorage.getUnsyncedData();

            // Sync form data first
            await this.syncFormData(unsyncedData.forms);

            // Then sync images
            await this.syncImages(unsyncedData.images);

            if (unsyncedData.images.length > 0 || unsyncedData.forms.length > 0) {
                this.showStatus('Toutes les donnÃ©es ont Ã©tÃ© synchronisÃ©es avec succÃ¨s.', 'success');
            }

        } catch (error) {
            console.error('Sync failed:', error);
            this.showStatus('Ã‰chec de la synchronisation â€“ une nouvelle tentative sera effectuÃ©e automatiquement.', 'error');
        } finally {
            this.syncInProgress = false;
        }
    }

    async syncFormData(forms) {
        for (const form of forms) {
            await this.retryOperation(async () => {
                await this.uploadFormData(form);
                await window.offlineStorage.markFormSynced(form.id);
            });
        }
    }

    async syncImages(images) {
        // Process images in batches to avoid overwhelming the server
        const batchSize = 3;
        for (let i = 0; i < images.length; i += batchSize) {
            const batch = images.slice(i, i + batchSize);
            await Promise.all(batch.map(image => this.syncSingleImage(image)));
        }
    }

    async syncSingleImage(image) {
        await this.retryOperation(async () => {
            const response = await this.uploadImage(image);
            if (response.success) {
                await window.offlineStorage.markImageUploaded(image.id, response.serverPath);
            }
        });
    }

    async uploadFormData(form) {
        const url = this.getFormUploadUrl(form.interventionId, form.stepName);

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify(form.data)
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        return response.json();
    }

    async uploadImage(image) {
        const url = this.getImageUploadUrl(image.interventionId, image.type);

        const formData = new FormData();
        formData.append('file', image.file);
        formData.append('token', this.getAuthToken());

        const response = await fetch(url, {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const result = await response.json();
        return {
            success: result.code === '1',
            serverPath: result.file_path,
            message: result.message
        };
    }

    async retryOperation(operation, retries = 0) {
        try {
            await operation();
        } catch (error) {
            if (retries < this.maxRetries) {
                await this.delay(this.retryDelay * (retries + 1));
                return this.retryOperation(operation, retries + 1);
            } else {
                throw error;
            }
        }
    }

    getFormUploadUrl(interventionId, stepName) {
        const urlMap = {
            'security': `/interventions/${interventionId}/security-checklist/`,
            'comment': `/interventions/${interventionId}/comment/`,
            'quality': `/interventions/${interventionId}/quality-control/`
        };
        return urlMap[stepName] || `/interventions/${interventionId}/${stepName}/`;
    }

    getImageUploadUrl(interventionId, type) {
        return type === 'before'
            ? `/interventions/${interventionId}/photo-upload/`
            : `/interventions/${interventionId}/photos-after/`;
    }

    getAuthToken() {
        // Get token from session or localStorage
        return document.querySelector('[name=csrfmiddlewaretoken]')?.value || '';
    }

    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    showStatus(message, type = 'info') {
        // Remove existing status
        const existingStatus = document.querySelector('.sync-status');
        if (existingStatus) {
            existingStatus.remove();
        }

        // Create status element
        const status = document.createElement('div');
        status.className = `sync-status fixed top-4 left-4 right-4 z-50 p-3 rounded-lg text-sm font-medium ${this.getStatusClasses(type)}`;
        status.textContent = message;

        document.body.appendChild(status);

        // Auto-hide after 5 seconds
        setTimeout(() => {
            if (status.parentNode) {
                status.remove();
            }
        }, 5000);
    }

    getStatusClasses(type) {
        const classes = {
            'success': 'bg-green-100 text-green-800 border border-green-200',
            'warning': 'bg-yellow-100 text-yellow-800 border border-yellow-200',
            'error': 'bg-red-100 text-red-800 border border-red-200',
            'info': 'bg-blue-100 text-blue-800 border border-blue-200'
        };
        return classes[type] || classes.info;
    }

    // Manual sync trigger
    async forcSync() {
        this.showStatus('DÃ©marrage de la synchronisation manuelle...', 'info');
        await this.syncAll();
    }

    // Get sync status
    async getSyncStatus() {
        const unsyncedData = await window.offlineStorage.getUnsyncedData();
        return {
            isOnline: this.isOnline,
            syncInProgress: this.syncInProgress,
            pendingImages: unsyncedData.images.length,
            pendingForms: unsyncedData.forms.length,
            totalPending: unsyncedData.images.length + unsyncedData.forms.length
        };
    }
}

// Initialize global sync manager
window.syncManager = new SyncManager();

// portal/static/js/offline-photo-upload.js
class OfflinePhotoUpload {
    constructor(interventionId, type = 'before') {
        this.interventionId = interventionId;
        this.type = type; // 'before' or 'after'
        this.uploadedImages = [];
        this.init();
    }

    async init() {
        await this.loadStoredImages();
        this.updateUI();
    }

    async loadStoredImages() {
        try {
            const storedImages = await window.offlineStorage.getImages(this.interventionId, this.type);
            this.uploadedImages = storedImages.map(img => ({
                id: img.id,
                filename: img.filename,
                url: img.serverPath || URL.createObjectURL(img.file),
                file: img.file,
                uploaded: img.uploaded,
                local: !img.uploaded
            }));
        } catch (error) {
            console.error('Error loading stored images:', error);
            this.uploadedImages = [];
        }
    }

    async handleImageUpload(files) {
        const uploadPromises = Array.from(files).map(file => this.processImage(file));
        await Promise.all(uploadPromises);
        this.updateUI();
    }

    async processImage(file) {
        try {
            // Compress image if too large
            const processedFile = await this.compressImage(file);

            // Store locally first
            await window.offlineStorage.storeImage(this.interventionId, processedFile, this.type);

            // Add to local array for immediate UI update
            const imageObj = {
                id: Date.now() + Math.random(), // Temporary ID
                filename: processedFile.name,
                url: URL.createObjectURL(processedFile),
                file: processedFile,
                uploaded: false,
                local: true
            };

            this.uploadedImages.push(imageObj);

            // Try to upload immediately if online
            if (navigator.onLine) {
                this.backgroundUpload(imageObj);
            }

            this.showToast('Image enregistrÃ©e localement â€“ sera tÃ©lÃ©versÃ©e lorsque la connexion sera disponible.', 'info');

        } catch (error) {
            console.error('Error processing image:', error);
            this.showToast('Erreur lors de l\'enregistrement de l\'image.: ' + error.message, 'error');
        }
    }

    async compressImage(file) {
        return new Promise((resolve) => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();

            img.onload = () => {
                // Calculate new dimensions (max 1920x1080)
                let { width, height } = img;
                const maxWidth = 1920;
                const maxHeight = 1080;

                if (width > height) {
                    if (width > maxWidth) {
                        height = (height * maxWidth) / width;
                        width = maxWidth;
                    }
                } else {
                    if (height > maxHeight) {
                        width = (width * maxHeight) / height;
                        height = maxHeight;
                    }
                }

                canvas.width = width;
                canvas.height = height;

                // Draw and compress
                ctx.drawImage(img, 0, 0, width, height);

                canvas.toBlob((blob) => {
                    const compressedFile = new File([blob], file.name, {
                        type: 'image/jpeg',
                        lastModified: Date.now()
                    });
                    resolve(compressedFile);
                }, 'image/jpeg', 0.8); // 80% quality
            };

            img.src = URL.createObjectURL(file);
        });
    }

    async backgroundUpload(imageObj) {
        try {
            const formData = new FormData();
            formData.append('file', imageObj.file);

            const url = this.type === 'before'
                ? `/interventions/${this.interventionId}/photo-upload/`
                : `/interventions/${this.interventionId}/photos-after/`;

            const response = await fetch(url, {
                method: 'POST',
                body: formData
            });

            const result = await response.json();

            if (result.code === '1') {
                // Mark as uploaded in storage
                await window.offlineStorage.markImageUploaded(imageObj.id, result.file_path);

                // Update local array
                const index = this.uploadedImages.findIndex(img => img.id === imageObj.id);
                if (index !== -1) {
                    this.uploadedImages[index].uploaded = true;
                    this.uploadedImages[index].local = false;
                    this.uploadedImages[index].url = `https://astro-tech.fr/astro-ges/${result.file_path}`;
                }

                this.updateUI();
                this.showToast(' Image tÃ©lÃ©versÃ©e avec succÃ¨s.', 'success');
            }

        } catch (error) {
            console.error('Background upload failed:', error);
            // Image remains in local storage for retry
        }
    }

    updateUI() {
        const photoBoxes = document.querySelectorAll('.photo-box');

        // Clear all boxes first
        photoBoxes.forEach(box => {
            box.innerHTML = this.getEmptyBoxContent();
        });

        // Display images
        this.uploadedImages.forEach((image, index) => {
            if (index < photoBoxes.length) {
                this.displayImageInBox(photoBoxes[index], image);
            }
        });

        // Update sync indicator
        this.updateSyncIndicator();
    }

    displayImageInBox(box, imageObj) {
        box.innerHTML = '';

        // Create image container
        const container = document.createElement('div');
        container.className = 'relative w-full h-full';

        // Create image element
        const img = document.createElement('img');
        img.src = imageObj.url;
        img.className = 'w-full h-full object-cover rounded';
        img.alt = imageObj.filename;

        // Add upload status indicator
        const statusIndicator = document.createElement('div');
        statusIndicator.className = `absolute top-1 left-1 w-3 h-3 rounded-full ${
            imageObj.uploaded ? 'bg-green-500' : 'bg-yellow-500'
        }`;
        statusIndicator.title = imageObj.uploaded ? 'Uploaded' : 'Pending upload';

        // Add delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'absolute top-0 right-0 w-6 h-6 bg-red-500 text-white rounded-full flex items-center justify-center transform translate-x-2 -translate-y-2';
        deleteBtn.innerHTML = 'Ã—';
        deleteBtn.onclick = (e) => {
            e.stopPropagation();
            this.deleteImage(imageObj.id);
        };

        container.appendChild(img);
        container.appendChild(statusIndicator);
        container.appendChild(deleteBtn);
        box.appendChild(container);
    }

    async deleteImage(imageId) {
        try {
            // Remove from IndexedDB
            const transaction = window.offlineStorage.db.transaction(['images'], 'readwrite');
            const store = transaction.objectStore('images');
            await store.delete(imageId);

            // Remove from local array
            this.uploadedImages = this.uploadedImages.filter(img => img.id !== imageId);

            this.updateUI();
            this.showToast('Image deleted', 'info');

        } catch (error) {
            console.error('Error deleting image:', error);
            this.showToast('Erreur lors de la suppression de l\'image', 'error');
        }
    }

    getEmptyBoxContent() {
        return `
            <button onclick="openGallery()" class="action-button">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                          d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                </svg>
            </button>
            <button onclick="openCamera()" class="action-button">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                          d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
            </button>
        `;
    }

    updateSyncIndicator() {
        const pendingCount = this.uploadedImages.filter(img => !img.uploaded).length;

        // Update or create sync indicator
        let indicator = document.querySelector('.sync-indicator');
        if (!indicator) {
            indicator = document.createElement('div');
            indicator.className = 'sync-indicator fixed top-20 right-4 z-40';
            document.body.appendChild(indicator);
        }

        if (pendingCount > 0) {
            indicator.innerHTML = `
                <div class="bg-yellow-500 text-white px-3 py-1 rounded-full text-sm font-medium shadow-lg">
                    ${pendingCount} pending upload${pendingCount > 1 ? 's' : ''}
                </div>
            `;
            indicator.style.display = 'block';
        } else {
            indicator.style.display = 'none';
        }
    }

    showToast(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `fixed bottom-20 left-4 right-4 p-3 rounded-lg text-sm font-medium z-50 ${this.getToastClasses(type)}`;
        toast.textContent = message;

        document.body.appendChild(toast);

        // Auto-remove after 3 seconds
        setTimeout(() => {
            if (toast.parentNode) {
                toast.remove();
            }
        }, 3000);
    }

    getToastClasses(type) {
        const classes = {
            'success': 'bg-green-500 text-white',
            'error': 'bg-red-500 text-white',
            'info': 'bg-blue-500 text-white',
            'warning': 'bg-yellow-500 text-white'
        };
        return classes[type] || classes.info;
    }

    // Get all images for this intervention and type
    async getAllImages() {
        return this.uploadedImages.map(img => ({
            filename: img.filename,
            url: img.uploaded ? img.url : null,
            uploaded: img.uploaded
        }));
    }

    // Check if all images are uploaded
    areAllImagesUploaded() {
        return this.uploadedImages.every(img => img.uploaded);
    }
}

// Global functions for photo boxes
function openGallery() {
    const input = document.getElementById('imageInput');
    if (input) {
        input.removeAttribute('capture');
        input.click();
    }
}

function openCamera() {
    const input = document.getElementById('imageInput');
    if (input) {
        input.setAttribute('capture', 'environment');
        input.click();
    }
}

// Initialize when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    // Wait for offline storage to be ready
    if (window.offlineStorage) {
        const pathParts = window.location.pathname.split('/');
        const interventionId = pathParts[2];
        const isAfter = window.location.pathname.includes('photos-after');
        const type = isAfter ? 'after' : 'before';

        window.photoUpload = new OfflinePhotoUpload(interventionId, type);

        // Handle file input change
        const imageInput = document.getElementById('imageInput');
        if (imageInput) {
            imageInput.addEventListener('change', (event) => {
                if (event.target.files.length > 0) {
                    window.photoUpload.handleImageUpload(event.target.files);
                    event.target.value = ''; // Reset input
                }
            });
        }
    }
});

// portal/static/js/offline-form-handler.js
class OfflineFormHandler {
    constructor() {
        this.init();
    }

    init() {
        this.setupFormHandlers();
        this.loadStoredData();
    }

    setupFormHandlers() {
        // Security checklist handler
        this.setupSecurityHandler();

        // Comment handler
        this.setupCommentHandler();

        // Quality control handler
        this.setupQualityHandler();

        // Voice recording handler
        this.setupVoiceHandler();
    }

    setupSecurityHandler() {
        const securityForm = document.querySelector('#security-form');
        if (securityForm) {
            const interventionId = this.getInterventionIdFromURL();

            // Load existing data
            this.loadSecurityData(interventionId);

            // Save on change
            const checkboxes = document.querySelectorAll('.custom-checkbox');
            checkboxes.forEach((checkbox, index) => {
                checkbox.addEventListener('click', () => {
                    setTimeout(() => {
                        this.saveSecurityData(interventionId);
                    }, 100);
                });
            });
        }
    }

    setupCommentHandler() {
        const commentInput = document.querySelector('#commentInput');
        if (commentInput) {
            const interventionId = this.getInterventionIdFromURL();

            // Load existing data
            this.loadCommentData(interventionId);

            // Auto-save on input with debounce
            let timeout;
            commentInput.addEventListener('input', () => {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    this.saveCommentData(interventionId, commentInput.value);
                }, 1000);
            });

            // Save on blur
            commentInput.addEventListener('blur', () => {
                this.saveCommentData(interventionId, commentInput.value);
            });
        }
    }

    setupQualityHandler() {
        const qualityForm = document.querySelector('#quality-control-form');
        if (qualityForm || document.querySelector('.custom-checkbox')) {
            const interventionId = this.getInterventionIdFromURL();

            // Load existing data
            this.loadQualityData(interventionId);

            // Save on checkbox change
            document.addEventListener('click', (e) => {
                if (e.target.classList.contains('custom-checkbox') ||
                    e.target.closest('.checkbox-item')) {
                    setTimeout(() => {
                        this.saveQualityData(interventionId);
                    }, 100);
                }
            });
        }
    }

    setupVoiceHandler() {
        const voiceSection = document.querySelector('.recording-container');
        if (voiceSection) {
            const interventionId = this.getInterventionIdFromURL();

            // Override the saveRecording function if it exists
            if (typeof window.saveRecording === 'function') {
                const originalSave = window.saveRecording;
                window.saveRecording = async () => {
                    if (!window.recordedBlob) return;

                    try {
                        // Store voice recording locally
                        await this.saveVoiceData(interventionId, window.recordedBlob);

                        // Try to upload if online
                        if (navigator.onLine) {
                            await originalSave();
                        } else {
                            this.showToast('Voice recording saved offline', 'info');
                            document.getElementById('nextButton').disabled = false;
                        }
                    } catch (error) {
                        console.error('Error saving voice recording:', error);
                        this.showToast('Error saving voice recording', 'error');
                    }
                };
            }
        }
    }

    async loadSecurityData(interventionId) {
        try {
            const data = await window.offlineStorage.getFormData(interventionId, 'security');
            if (data && data.data && data.data.security) {
                const checkboxStates = data.data.security.split(';');
                checkboxStates.forEach((state, index) => {
                    const checkbox = document.getElementById(`checkbox-${index}`);
                    if (checkbox && state === '1') {
                        checkbox.classList.add('checked');
                        if (window.qualityChecks && window.qualityChecks.length > index) {
                            window.qualityChecks[index] = true;
                        }
                    }
                });
            }
        } catch (error) {
            console.error('Error loading security data:', error);
        }
    }

    async saveSecurityData(interventionId) {
        try {
            const checkboxes = document.querySelectorAll('.custom-checkbox');
            const states = Array.from(checkboxes).map(cb =>
                cb.classList.contains('checked') ? '1' : '0'
            );

            const data = {
                security: states.join(';')
            };

            await window.offlineStorage.storeFormData(interventionId, 'security', data);
            this.showOfflineIndicator('Liste de contrÃ´le de sÃ©curitÃ© enregistrÃ©e hors ligne.');

        } catch (error) {
            console.error('Error saving security data:', error);
        }
    }

    async loadCommentData(interventionId) {
        try {
            const data = await window.offlineStorage.getFormData(interventionId, 'comment');
            if (data && data.data && data.data.comment) {
                const commentInput = document.getElementById('commentInput');
                if (commentInput) {
                    commentInput.value = data.data.comment;
                }
            }
        } catch (error) {
            console.error('Error loading comment data:', error);
        }
    }

    async saveCommentData(interventionId, comment) {
        try {
            const data = {
                comment: comment
            };

            await window.offlineStorage.storeFormData(interventionId, 'comment', data);
            this.showOfflineIndicator('Comment saved offline');

        } catch (error) {
            console.error('Error saving comment data:', error);
        }
    }

    async loadQualityData(interventionId) {
        try {
            const data = await window.offlineStorage.getFormData(interventionId, 'quality');
            if (data && data.data && data.data.quality) {
                const qualityStates = data.data.quality.split(';');
                qualityStates.forEach((state, index) => {
                    const checkbox = document.getElementById(`checkbox-${index}`);
                    if (checkbox && state === '1') {
                        checkbox.classList.add('checked');
                        if (window.qualityChecks && window.qualityChecks.length > index) {
                            window.qualityChecks[index] = true;
                        }
                    }
                });
            }
        } catch (error) {
            console.error('Error loading quality data:', error);
        }
    }

    async saveQualityData(interventionId) {
        try {
            const checkboxes = document.querySelectorAll('.custom-checkbox');
            const states = Array.from(checkboxes).map(cb =>
                cb.classList.contains('checked') ? '1' : '0'
            );

            const data = {
                quality: states.join(';')
            };

            await window.offlineStorage.storeFormData(interventionId, 'quality', data);
            this.showOfflineIndicator('Quality control saved offline');

        } catch (error) {
            console.error('Error saving quality data:', error);
        }
    }

    async saveVoiceData(interventionId, blob) {
        try {
            // Convert blob to file
            const voiceFile = new File([blob], `voice_${interventionId}_${Date.now()}.wav`, {
                type: 'audio/wav'
            });

            // Store as image with type 'voice'
            await window.offlineStorage.storeImage(interventionId, voiceFile, 'voice');

        } catch (error) {
            console.error('Error saving voice data:', error);
            throw error;
        }
    }

    getInterventionIdFromURL() {
        const pathParts = window.location.pathname.split('/');
        return pathParts[2] || null;
    }

    showOfflineIndicator(message) {
        if (!navigator.onLine) {
            this.showToast(message, 'info');
        }
    }

    showToast(message, type = 'info') {
        // Remove existing toast
        const existingToast = document.querySelector('.offline-toast');
        if (existingToast) {
            existingToast.remove();
        }

        const toast = document.createElement('div');
        toast.className = `offline-toast fixed bottom-20 left-4 right-4 p-3 rounded-lg text-sm font-medium z-50 ${this.getToastClasses(type)}`;
        toast.textContent = message;

        document.body.appendChild(toast);

        // Auto-remove after 3 seconds
        setTimeout(() => {
            if (toast.parentNode) {
                toast.remove();
            }
        }, 3000);
    }

    getToastClasses(type) {
        const classes = {
            'success': 'bg-green-500 text-white',
            'error': 'bg-red-500 text-white',
            'info': 'bg-blue-500 text-white',
            'warning': 'bg-yellow-500 text-white'
        };
        return classes[type] || classes.info;
    }

    // Override navigation functions to work offline
    setupOfflineNavigation() {
        // Override the original submit functions
        if (typeof window.submitForm === 'function') {
            const originalSubmit = window.submitForm;
            window.submitForm = async () => {
                if (navigator.onLine) {
                    try {
                        await originalSubmit();
                    } catch (error) {
                        // If online submission fails, allow offline navigation
                        this.navigateToNext();
                    }
                } else {
                    this.navigateToNext();
                }
            };
        }

        // Override save functions
        if (typeof window.saveCommentData === 'function') {
            const originalSave = window.saveCommentData;
            window.saveCommentData = async () => {
                const interventionId = this.getInterventionIdFromURL();
                const commentInput = document.getElementById('commentInput');

                // Always save offline first
                if (commentInput) {
                    await this.saveCommentData(interventionId, commentInput.value);
                }

                // Try online if available
                if (navigator.onLine) {
                    try {
                        await originalSave();
                    } catch (error) {
                        console.error('Online save failed:', error);
                    }
                }

                // Always show success
                document.getElementById('confirmationMessage').style.display = 'block';
            };
        }

        // Similar overrides for quality control
        if (typeof window.saveQualityControl === 'function') {
            const originalSave = window.saveQualityControl;
            window.saveQualityControl = async (shouldNavigate) => {
                const interventionId = this.getInterventionIdFromURL();

                // Always save offline first
                await this.saveQualityData(interventionId);

                // Try online if available
                if (navigator.onLine) {
                    try {
                        await originalSave(shouldNavigate);
                        return;
                    } catch (error) {
                        console.error('Online save failed:', error);
                    }
                }

                // Show success message
                if (!shouldNavigate) {
                    document.getElementById('confirmationMessage').style.display = 'block';
                }
            };
        }
    }

    navigateToNext() {
        // Get the next URL based on current page
        const currentPath = window.location.pathname;
        const interventionId = this.getInterventionIdFromURL();

        const stepMap = {
            'security-checklist': 'photo-upload',
            'photo-upload': 'photos-after',
            'photos-after': 'comment',
            'comment': 'quality-control',
            'quality-control': 'signature'
        };

        for (const [current, next] of Object.entries(stepMap)) {
            if (currentPath.includes(current)) {
                window.location.href = `/interventions/${interventionId}/${next}/`;
                return;
            }
        }
    }
}

// Initialize offline form handler
document.addEventListener('DOMContentLoaded', () => {
    if (window.offlineStorage) {
        window.offlineFormHandler = new OfflineFormHandler();
    }
});

// portal/static/js/offline-navigation.js
class OfflineNavigation {
    constructor() {
        this.init();
    }

    init() {
        this.createStatusBar();
        this.setupNavigationOverrides();
        this.setupOfflineInterventionList();
        this.monitorConnectionStatus();
    }

    createStatusBar() {
        const statusBar = document.createElement('div');
        statusBar.id = 'offline-status-bar';
        statusBar.className = 'fixed top-0 left-0 right-0 z-50 transition-all duration-300';
        statusBar.style.transform = 'translateY(-100%)';

        document.body.appendChild(statusBar);
        this.updateStatusBar();
    }

    updateStatusBar() {
        const statusBar = document.getElementById('offline-status-bar');
        if (!statusBar) return;

        if (!navigator.onLine) {
            statusBar.innerHTML = `
                <div class="bg-yellow-500 text-white text-center py-2 px-4 text-sm font-medium">
                    <div class="flex items-center justify-center gap-2">
                        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                        </svg>
                        Working Offline - Data will sync when connection is restored
                        <button onclick="window.offlineNav.showSyncStatus()" class="underline">
                            View Status
                        </button>
                    </div>
                </div>
            `;
            statusBar.style.transform = 'translateY(0%)';

            // Adjust body padding
            document.body.style.paddingTop = statusBar.offsetHeight + 'px';
        } else {
            statusBar.style.transform = 'translateY(-100%)';
            document.body.style.paddingTop = '0px';

            // Show sync indicator if there's pending data
            this.showSyncIndicatorIfNeeded();
        }
    }

    async showSyncIndicatorIfNeeded() {
        try {
            const status = await window.syncManager.getSyncStatus();
            if (status.totalPending > 0) {
                const statusBar = document.getElementById('offline-status-bar');
                statusBar.innerHTML = `
                    <div class="bg-blue-500 text-white text-center py-2 px-4 text-sm font-medium">
                        <div class="flex items-center justify-center gap-2">
                            <div class="animate-spin w-4 h-4 border-2 border-white border-t-transparent rounded-full"></div>
                            Syncing ${status.totalPending} item${status.totalPending > 1 ? 's' : ''}...
                            <button onclick="window.offlineNav.showSyncStatus()" class="underline">
                                Details
                            </button>
                        </div>
                    </div>
                `;
                statusBar.style.transform = 'translateY(0%)';
                document.body.style.paddingTop = statusBar.offsetHeight + 'px';

                // Hide after sync completes
                setTimeout(async () => {
                    const newStatus = await window.syncManager.getSyncStatus();
                    if (newStatus.totalPending === 0) {
                        statusBar.style.transform = 'translateY(-100%)';
                        document.body.style.paddingTop = '0px';
                    }
                }, 5000);
            }
        } catch (error) {
            console.error('Error checking sync status:', error);
        }
    }

    setupNavigationOverrides() {
        // Override all form submissions to work offline
        document.addEventListener('submit', (e) => {
            e.preventDefault();
            this.handleFormSubmission(e.target);
        });

        // Override AJAX calls to work offline
        this.interceptFetch();
    }

    async handleFormSubmission(form) {
        const interventionId = this.getInterventionIdFromURL();
        const formData = new FormData(form);

        // Determine the step type
        const stepType = this.getStepTypeFromURL();

        try {
            // Always save offline first
            await this.saveFormDataOffline(interventionId, stepType, formData);

            // Try online submission if available
            if (navigator.onLine) {
                try {
                    await this.submitFormOnline(form);
                } catch (error) {
                    console.log('Online submission failed, continuing offline');
                }
            }

            // Navigate to next step
            this.navigateToNextStep();

        } catch (error) {
            console.error('Form submission error:', error);
            this.showError('Error saving data: ' + error.message);
        }
    }

    async saveFormDataOffline(interventionId, stepType, formData) {
        const data = {};
        for (const [key, value] of formData.entries()) {
            data[key] = value;
        }

        await window.offlineStorage.storeFormData(interventionId, stepType, data);
    }

    async submitFormOnline(form) {
        const response = await fetch(form.action || window.location.href, {
            method: 'POST',
            body: new FormData(form)
        });

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        return response.json();
    }

    setupOfflineInterventionList() {
        // Cache intervention list for offline viewing
        if (window.location.pathname.includes('interventions') &&
            !window.location.pathname.includes('interventions/')) {
            this.cacheInterventionList();
        }
    }

    async cacheInterventionList() {
        try {
            // Get interventions from the page and store them
            const interventionCards = document.querySelectorAll('.intervention-card');
            const interventions = [];

            interventionCards.forEach(card => {
                const link = card.closest('a');
                if (link) {
                    const uid = link.href.split('/').slice(-2, -1)[0];
                    const title = card.querySelector('.text-blue-400, .text-red-400, .text-yellow-400')?.textContent;
                    const type = card.querySelector('.text-gray-400')?.textContent;
                    const address = card.querySelector('.flex.items-center:nth-child(2)')?.textContent;

                    interventions.push({
                        uid,
                        title,
                        type,
                        address,
                        cached: true
                    });
                }
            });

            // Store interventions
            for (const intervention of interventions) {
                await window.offlineStorage.storeIntervention(intervention);
            }

        } catch (error) {
            console.error('Error caching interventions:', error);
        }
    }

    monitorConnectionStatus() {
        window.addEventListener('online', () => {
            this.updateStatusBar();
            // Start sync immediately
            if (window.syncManager) {
                window.syncManager.syncAll();
            }
        });

        window.addEventListener('offline', () => {
            this.updateStatusBar();
        });

        // Check connection periodically
        setInterval(() => {
            this.updateStatusBar();
        }, 30000);
    }

    interceptFetch() {
        const originalFetch = window.fetch;

        window.fetch = async (url, options = {}) => {
            try {
                // Try normal fetch first
                return await originalFetch(url, options);
            } catch (error) {
                // If offline or fetch fails, handle gracefully
                if (!navigator.onLine) {
                    return this.handleOfflineFetch(url, options);
                }
                throw error;
            }
        };
    }

    async handleOfflineFetch(url, options) {
        // Return a mock response for certain endpoints
        if (url.includes('/interventions/') && options.method === 'POST') {
            // For form submissions, return success
            return new Response(JSON.stringify({ success: true }), {
                status: 200,
                headers: { 'Content-Type': 'application/json' }
            });
        }

        // For other requests, throw offline error
        throw new Error('Network unavailable - working offline');
    }

    navigateToNextStep() {
        const currentPath = window.location.pathname;
        const interventionId = this.getInterventionIdFromURL();

        const stepMap = {
            'security-checklist': 'photo-upload',
            'photo-upload': 'photos-after',
            'photos-after': 'comment',
            'comment': 'quality-control',
            'quality-control': 'signature'
        };

        for (const [current, next] of Object.entries(stepMap)) {
            if (currentPath.includes(current)) {
                window.location.href = `/interventions/${interventionId}/${next}/`;
                return;
            }
        }

        // If we're on signature page, go back to intervention list
        if (currentPath.includes('signature')) {
            window.location.href = '/interventions/';
        }
    }

    getStepTypeFromURL() {
        const path = window.location.pathname;
        if (path.includes('security-checklist')) return 'security';
        if (path.includes('comment')) return 'comment';
        if (path.includes('quality-control')) return 'quality';
        if (path.includes('voice-recording')) return 'voice';
        return 'unknown';
    }

    getInterventionIdFromURL() {
        const pathParts = window.location.pathname.split('/');
        return pathParts[2] || null;
    }

    async showSyncStatus() {
        try {
            const status = await window.syncManager.getSyncStatus();
            const unsyncedData = await window.offlineStorage.getUnsyncedData();

            // Create status modal
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4';

            modal.innerHTML = `
                <div class="bg-white rounded-lg p-6 max-w-md w-full max-h-96 overflow-y-auto">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-lg font-bold">Sync Status</h3>
                        <button onclick="this.closest('.fixed').remove()" class="text-gray-500 hover:text-gray-700">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>

                    <div class="space-y-4">
                        <div class="flex items-center gap-2">
                            <div class="w-3 h-3 rounded-full ${status.isOnline ? 'bg-green-500' : 'bg-red-500'}"></div>
                            <span class="font-medium">${status.isOnline ? 'Online' : 'Offline'}</span>
                        </div>

                        <div class="border-t pt-4">
                            <h4 class="font-medium mb-2">Pending Uploads</h4>
                            <div class="text-sm text-gray-600">
                                <p>${status.pendingImages} image(s)</p>
                                <p>${status.pendingForms} form(s)</p>
                            </div>
                        </div>

                        ${status.totalPending > 0 ? `
                            <button onclick="window.syncManager.forcSync(); this.closest('.fixed').remove();"
                                    class="w-full bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-600">
                                Force Sync Now
                            </button>
                        ` : `
                            <div class="text-green-600 text-center py-2">
                                âœ“ All data synchronized
                            </div>
                        `}

                        <div class="border-t pt-4">
                            <h4 class="font-medium mb-2">Storage Usage</h4>
                            <button onclick="window.offlineNav.showStorageDetails()"
                                    class="text-blue-500 text-sm hover:underline">
                                View Storage Details
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);

        } catch (error) {
            console.error('Error showing sync status:', error);
        }
    }

    async showStorageDetails() {
        try {
            // Calculate storage usage
            const estimate = await navigator.storage.estimate();
            const usedMB = (estimate.usage / (1024 * 1024)).toFixed(2);
            const quotaMB = (estimate.quota / (1024 * 1024)).toFixed(2);

            // Get data counts
            const unsyncedData = await window.offlineStorage.getUnsyncedData();
            const interventions = await window.offlineStorage.getStoredInterventions();

            alert(`Storage Usage:
Used: ${usedMB} MB of ${quotaMB} MB

Stored Data:
- ${unsyncedData.images.length} images
- ${unsyncedData.forms.length} forms
- ${interventions.length} interventions

Tip: Clear old data regularly to free up space.`);

        } catch (error) {
            console.error('Error showing storage details:', error);
            alert('Unable to retrieve storage information');
        }
    }

    showError(message) {
        const error = document.createElement('div');
        error.className = 'fixed bottom-4 left-4 right-4 bg-red-500 text-white p-4 rounded-lg z-50';
        error.textContent = message;

        document.body.appendChild(error);

        setTimeout(() => {
            if (error.parentNode) {
                error.remove();
            }
        }, 5000);
    }
}

// Initialize offline navigation
document.addEventListener('DOMContentLoaded', () => {
    if (window.offlineStorage) {
        window.offlineNav = new OfflineNavigation();
    }
});

// public/service-worker.js
const CACHE_NAME = 'astro-tech-v1';
const urlsToCache = [
    '/',
    '/static/js/offline-storage.js',
    '/static/js/sync-manager.js',
    '/static/js/offline-photo-upload.js',
    '/static/js/offline-form-handler.js',
    '/static/js/offline-navigation.js',
    '/static/css/main.css',
    '/interventions/',
    'https://cdn.tailwindcss.com',
    'https://astro-tech.fr/astro-ges/uploads/images/astro-logo.png'
];

// Install event - cache resources
self.addEventListener('install', function(event) {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(function(cache) {
                console.log('Opened cache');
                return cache.addAll(urlsToCache);
            })
    );
});

// Fetch event - serve from cache when offline
self.addEventListener('fetch', function(event) {
    event.respondWith(
        caches.match(event.request)
            .then(function(response) {
                // Return cached version or fetch from network
                if (response) {
                    return response;
                }

                return fetch(event.request).then(function(response) {
                    // Don't cache if not a valid response
                    if (!response || response.status !== 200 || response.type !== 'basic') {
                        return response;
                    }

                    // Clone the response
                    const responseToCache = response.clone();

                    caches.open(CACHE_NAME)
                        .then(function(cache) {
                            cache.put(event.request, responseToCache);
                        });

                    return response;
                }).catch(function() {
                    // If both cache and network fail, return offline page
                    if (event.request.destination === 'document') {
                        return caches.match('/offline.html');
                    }
                });
            })
    );
});

// Activate event - clean up old caches
self.addEventListener('activate', function(event) {
    event.waitUntil(
        caches.keys().then(function(cacheNames) {
            return Promise.all(
                cacheNames.map(function(cacheName) {
                    if (cacheName !== CACHE_NAME) {
                        return caches.delete(cacheName);
                    }
                })
            );
        })
    );
});

// Background sync
self.addEventListener('sync', function(event) {
    if (event.tag === 'background-sync') {
        event.waitUntil(doBackgroundSync());
    }
});

async function doBackgroundSync() {
    try {
        // Open IndexedDB and sync pending data
        const db = await openIndexedDB();

        // Get all unsynced data
        const transaction = db.transaction(['images', 'formData'], 'readonly');
        const imageStore = transaction.objectStore('images');
        const formStore = transaction.objectStore('formData');

        // Get unsynced images
        const unuploadedImages = await getAll(imageStore.index('uploaded'), false);

        // Get unsynced forms
        const unsyncedForms = await getAll(formStore.index('synced'), false);

        // Sync forms first
        for (const form of unsyncedForms) {
            await syncFormData(form);
        }

        // Then sync images
        for (const image of unuploadedImages) {
            await syncImageData(image);
        }

        console.log('Background sync completed');

    } catch (error) {
        console.error('Background sync failed:', error);
    }
}

function openIndexedDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open('AstroTechDB', 1);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}

function getAll(index, key) {
    return new Promise((resolve, reject) => {
        const request = index.getAll(key);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
}

async function syncFormData(form) {
    const url = getFormUploadUrl(form.interventionId, form.stepName);

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(form.data)
        });

        if (response.ok) {
            // Mark as synced
            const db = await openIndexedDB();
            const transaction = db.transaction(['formData'], 'readwrite');
            const store = transaction.objectStore('formData');

            form.synced = true;
            form.syncedAt = new Date().toISOString();
            await store.put(form);
        }

    } catch (error) {
        console.error('Failed to sync form data:', error);
        throw error;
    }
}

async function syncImageData(image) {
    const url = getImageUploadUrl(image.interventionId, image.type);

    try {
        const formData = new FormData();
        formData.append('file', image.file);

        const response = await fetch(url, {
            method: 'POST',
            body: formData
        });

        if (response.ok) {
            const result = await response.json();
            if (result.code === '1') {
                // Mark as uploaded
                const db = await openIndexedDB();
                const transaction = db.transaction(['images'], 'readwrite');
                const store = transaction.objectStore('images');

                image.uploaded = true;
                image.serverPath = result.file_path;
                image.uploadedAt = new Date().toISOString();
                await store.put(image);
            }
        }

    } catch (error) {
        console.error('Failed to sync image data:', error);
        throw error;
    }
}

function getFormUploadUrl(interventionId, stepName) {
    const urlMap = {
        'security': `/interventions/${interventionId}/security-checklist/`,
        'comment': `/interventions/${interventionId}/comment/`,
        'quality': `/interventions/${interventionId}/quality-control/`
    };
    return urlMap[stepName] || `/interventions/${interventionId}/${stepName}/`;
}

function getImageUploadUrl(interventionId, type) {
    return type === 'before'
        ? `/interventions/${interventionId}/photo-upload/`
        : `/interventions/${interventionId}/photos-after/`;
}

// Handle push notifications
self.addEventListener('push', function(event) {
    if (event.data) {
        const data = event.data.json();
        const options = {
            body: data.body,
            icon: '/static/images/icon-192x192.png',
            badge: '/static/images/badge-72x72.png',
            data: {
                url: data.url
            },
            actions: [
                {
                    action: 'view',
                    title: 'View Intervention'
                },
                {
                    action: 'dismiss',
                    title: 'Dismiss'
                }
            ]
        };

        event.waitUntil(
            self.registration.showNotification(data.title, options)
        );
    }
});

// Handle notification clicks
self.addEventListener('notificationclick', function(event) {
    event.notification.close();

    if (event.action === 'view' && event.notification.data && event.notification.data.url) {
        event.waitUntil(
            clients.openWindow(event.notification.data.url)
        );
    } else if (event.action === 'dismiss') {
        // Just close the notification
    }
});

// Message handling for sync requests from main thread
self.addEventListener('message', function(event) {
    if (event.data && event.data.type === 'SYNC_REQUEST') {
        event.waitUntil(doBackgroundSync());
    }
});
    </script>

    {% block extra_js %}{% endblock %}
</body>
</html>